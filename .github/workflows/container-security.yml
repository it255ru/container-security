name: Dockerfile Security Scan

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  dockerfile-scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Run Hadolint
      uses: hadolint/hadolint-action@v3.1.0
      with:
        dockerfile: Dockerfile
        format: json
        output-file: hadolint-results.json
      continue-on-error: true
      
    - name: Try to build Docker image
      id: build
      continue-on-error: true
      run: |
        echo "🔄 Attempting to build Docker image..."
        if docker build -t test-image . 2> build-errors.log 1> build-output.log; then
          echo "✅ Docker build successful"
          echo "build_success=true" >> $GITHUB_OUTPUT
        else
          echo "❌ Docker build failed"
          echo "build_success=false" >> $GITHUB_OUTPUT
          # Сохраняем ошибки в удобочитаемом формате
          echo "### Build Errors:" > build-results.md
          echo '```' >> build-results.md
          cat build-errors.log >> build-results.md
          echo '```' >> build-results.md
        fi
      
    - name: Custom Dockerfile analysis
      id: analysis
      env:
        BUILD_SUCCESS: ${{ steps.build.outputs.build_success }}
      run: |
        # Отключаем немедленный выход при ошибках для этого шага
        set +e
        
        echo "## 📋 Dockerfile Analysis Results" > analysis-results.md
        echo "" >> analysis-results.md
        echo "**Scan date:** $(date)" >> analysis-results.md
        echo "**Commit:** ${{ github.sha }}" >> analysis-results.md
        echo "**Branch:** ${{ github.ref }}" >> analysis-results.md
        echo "" >> analysis-results.md
        
        # Инициализация счетчиков
        ISSUE_COUNT=0
        CRITICAL_COUNT=0
        
        echo "### 🔍 Found Issues:" >> analysis-results.md
        
        # Универсальные проверки для любого Dockerfile
        
        # 1. Проверка на ADD вместо COPY (универсальная)
        if grep "ADD" Dockerfile > /dev/null 2>&1; then
          echo "❌ **WARNING**: Используется ADD вместо COPY. COPY предпочтительнее для файлов" >> analysis-results.md
          ISSUE_COUNT=$((ISSUE_COUNT + 1))
        fi
        
        # 2. Проверка на базовые образы без версий (универсальная)
        if grep -E "FROM.*:(latest| )" Dockerfile > /dev/null 2>&1 || 
           grep -E "^FROM [^:]+$" Dockerfile > /dev/null 2>&1; then
          echo "⚠️ **WARNING**: Базовый образ без конкретной версии. Всегда указывайте версию тега" >> analysis-results.md
          ISSUE_COUNT=$((ISSUE_COUNT + 1))
        fi
        
        # 3. Проверка на curl | bash (универсальная и критическая)
        if grep -E "curl.*\|.*bash" Dockerfile > /dev/null 2>&1 || 
           grep -E "wget.*\|.*bash" Dockerfile > /dev/null 2>&1; then
          echo "🚨 **CRITICAL**: Обнаружен опасный паттерн 'curl/wget | bash'. Это угроза безопасности!" >> analysis-results.md
          ISSUE_COUNT=$((ISSUE_COUNT + 1))
          CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
        fi
        
        # 4. Проверка прав 777 (универсальная и критическая)
        if grep -E "chmod.*777" Dockerfile > /dev/null 2>&1 || 
           grep -E "777" Dockerfile > /dev/null 2>&1; then
          echo "🚨 **CRITICAL**: Используются права 777 - это серьезная уязвимость безопасности!" >> analysis-results.md
          ISSUE_COUNT=$((ISSUE_COUNT + 1))
          CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
        fi
        
        # 5. Проверка на установку пакетов без очистки кеша (универсальная)
        if grep -E "(apt-get|apk|yum|dnf) install" Dockerfile > /dev/null 2>&1 && 
           ! grep -E "(apt-get clean|rm -rf /var/cache/|apk cache clean|yum clean|dnf clean)" Dockerfile > /dev/null 2>&1; then
          echo "⚠️ **WARNING**: Установка пакетов без очистки кеша. Увеличивает размер образа" >> analysis-results.md
          ISSUE_COUNT=$((ISSUE_COUNT + 1))
        fi
        
        # 6. Проверка на работу от root пользователя (универсальная)
        if ! grep -E "USER.*(?!root)" Dockerfile > /dev/null 2>&1 && 
           grep -E "RUN" Dockerfile > /dev/null 2>&1; then
          echo "⚠️ **WARNING**: Контейнер работает от root пользователя. Рекомендуется создать non-root пользователя" >> analysis-results.md
          ISSUE_COUNT=$((ISSUE_COUNT + 1))
        fi
        
        # 7. Проверка на множественные RUN инструкции (универсальная)
        RUN_COUNT=$(grep -c "^RUN " Dockerfile 2>/dev/null || echo "0")
        if [ "$RUN_COUNT" -gt 5 ]; then
          echo "⚠️ **WARNING**: Много RUN инструкций ($RUN_COUNT). Консолидируйте их для уменьшения слоев" >> analysis-results.md
          ISSUE_COUNT=$((ISSUE_COUNT + 1))
        fi
        
        # 8. Проверка на отсутствие .dockerignore (универсальная)
        if [ ! -f ".dockerignore" ]; then
          echo "⚠️ **WARNING**: Отсутствует .dockerignore файл. Рекомендуется добавить для уменьшения размера контекста" >> analysis-results.md
          ISSUE_COUNT=$((ISSUE_COUNT + 1))
        fi
        
        # Проверка результатов сборки
        if [ "$BUILD_SUCCESS" = "false" ]; then
          echo "" >> analysis-results.md
          echo "### 🛠 Docker Build Results:" >> analysis-results.md
          echo "🚨 **CRITICAL**: Docker image failed to build!" >> analysis-results.md
          if [ -f build-results.md ]; then
            cat build-results.md >> analysis-results.md
          else
            echo "Build errors were captured but details are not available." >> analysis-results.md
          fi
          ISSUE_COUNT=$((ISSUE_COUNT + 1))
          CRITICAL_COUNT=$((CRITICAL_COUNT + 1))
        else
          echo "" >> analysis-results.md
          echo "### 🛠 Docker Build Results:" >> analysis-results.md
          echo "✅ Docker image built successfully" >> analysis-results.md
        fi
        
        # Анализ Hadolint результатов
        HADOLINT_COUNT=0
        if [ -f hadolint-results.json ]; then
          echo "" >> analysis-results.md
          echo "### 🐳 Hadolint Results:" >> analysis-results.md
          
          # Проверяем валидность JSON
          if jq -e . hadolint-results.json > /dev/null 2>&1; then
            HADOLINT_COUNT=$(jq '. | length' hadolint-results.json 2>/dev/null || echo "0")
            if [ "$HADOLINT_COUNT" -gt 0 ]; then
              jq -r '.[] | "• **\(.level)**: Line \(.line): \(.message) (код: \(.code))"' hadolint-results.json 2>/dev/null >> analysis-results.md || echo "• Ошибка обработки результатов Hadolint" >> analysis-results.md
            else
              echo "✅ No Hadolint issues found" >> analysis-results.md
            fi
          else
            echo "• Невалидный JSON файл результатов Hadolint" >> analysis-results.md
          fi
        else
          echo "" >> analysis-results.md
          echo "### 🐳 Hadolint Results:" >> analysis-results.md
          echo "• Файл результатов не найден" >> analysis-results.md
        fi
        
        # Суммируем все проблемы
        ISSUE_COUNT=$((ISSUE_COUNT + HADOLINT_COUNT))
        
        echo "" >> analysis-results.md
        echo "---" >> analysis-results.md
        echo "**Summary:** Найдено $ISSUE_COUNT проблем ($CRITICAL_COUNT критических)" >> analysis-results.md
        
        # Сохраняем выходные переменные
        echo "issue_count=$ISSUE_COUNT" >> $GITHUB_OUTPUT
        echo "critical_count=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
        
        # Всегда завершаем успешно, даже если есть проблемы
        exit 0
        
    - name: Create or Update Issue
      uses: actions/github-script@v6
      if: steps.analysis.outputs.issue_count > 0
      env:
        ISSUE_COUNT: ${{ steps.analysis.outputs.issue_count }}
        CRITICAL_COUNT: ${{ steps.analysis.outputs.critical_count }}
      with:
        script: |
          const fs = require('fs');
          const report = fs.readFileSync('analysis-results.md', 'utf8');
          const issueCount = process.env.ISSUE_COUNT;
          const criticalCount = process.env.CRITICAL_COUNT;
          
          const title = `🚨 Dockerfile Security Issues: ${issueCount} problems found (${criticalCount} critical)`;
          
          // Ищем существующий issue
          const { data: issues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: ['dockerfile-security']
          });
          
          const existingIssue = issues.find(issue => 
            issue.title.includes('Dockerfile Security Issues')
          );
          
          const body = `${report}
          
          ---
          *Автоматически создано workflow [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})*
          `;
          
          if (existingIssue) {
            // Обновляем существующий issue
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existingIssue.number,
              title: title,
              body: body
            });
            console.log(`Updated existing issue #${existingIssue.number}`);
          } else {
            // Создаем новый issue
            const { data: newIssue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['dockerfile-security', 'security', 'ci-cd']
            });
            console.log(`Created new issue #${newIssue.number}`);
          }
          
    - name: Close existing issue if no problems
      uses: actions/github-script@v6
      if: steps.analysis.outputs.issue_count == 0
      with:
        script: |
          // Ищем открытый issue по безопасности Dockerfile
          const { data: issues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: ['dockerfile-security']
          });
          
          const existingIssue = issues.find(issue => 
            issue.title.includes('Dockerfile Security Issues')
          );
          
          if (existingIssue) {
            // Закрываем issue с комментарием
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existingIssue.number,
              state: 'closed'
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existingIssue.number,
              body: `✅ Все проблемы в Dockerfile исправлены в коммите ${context.sha}`
            });
            
            console.log(`Closed issue #${existingIssue.number}`);
          }
          
    - name: Fail if critical issues found
      if: steps.analysis.outputs.critical_count > 0
      run: |
        echo "❌ Найдены критические проблемы в Dockerfile: ${{ steps.analysis.outputs.critical_count }}"
        echo "Пожалуйста, исправьте их перед мерджем"
        echo "Подробности в созданном Issue"
        exit 1
        
    - name: Post PR comment
      uses: actions/github-script@v6
      if: github.event_name == 'pull_request' && steps.analysis.outputs.issue_count > 0
      env:
        ISSUE_COUNT: ${{ steps.analysis.outputs.issue_count }}
        CRITICAL_COUNT: ${{ steps.analysis.outputs.critical_count }}
      with:
        script: |
          const fs = require('fs');
          const report = fs.readFileSync('analysis-results.md', 'utf8');
          const issueCount = process.env.ISSUE_COUNT;
          const criticalCount = process.env.CRITICAL_COUNT;
          
          const commentBody = `## 🔍 Dockerfile Security Scan
          
          ${report}
          
          *Проверка выполнена автоматически*`;
          
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: commentBody
          });
